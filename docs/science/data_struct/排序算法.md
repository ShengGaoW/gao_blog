# 排序算法

## 选择排序

n 个数排序 n-1 次找最小值的过程，即先找 n 个数里面的最小值，再找剩余 n-1 个数值里面的最小值，再找剩余 n-2 个里面的最小值，。。。。。。 最后找剩余两个数里面的最小值，剩余一个数就是 n 个数里面的最大值。

由此可知， n 个数的选择排序是一个两重循环的问题：外层循环控制求最小值的次数，n-1 次求最小值由 n-1 次外循环实现，假设外循环变量为 i, 则 i 的循环范围为 0 ~ n-2; 内层循环完成求一个最小值的过程，假定当前元素 a[i] 是最小值假设内循环变量为 j, 让 a[i] 与其后的所有元素 a[j] 逐个比较，j 的范围即为 i+1 ~ n-1

对于以下这样的10个数字的排列，按照上述的排序方法，程序在执行中，元素 a[0] 依次与后面的 a[1]、。。。。。。a[9]相比较，每次 a[0] 都比后面的数字大，每次比较都要做交换，而这还仅仅是找一次最小值的过程。如果元素比较多时就会有大量的多与交换存在，影响程序的执行效率。于是程序可以进行改造：

每一次找最小值只需要一次交换，即初始位置与最小值元素做交换。在外层循环控制求最小次数的过程中，定义一个变量 min, 赋初值为当前的初始变量的下标 i, 在内层循环找最小值的过程中，如果发现当前元素的值比初始变量的值小，则将新的最小值的下标赋予 min。内层循环一趟结束，找到最小值后，判断 min 值是否发生了变化，变化了则进行位置交换，否则不需要交换。
 

``` c
int a[10] = {10,9,8,7,6,5,4,3,2,1}; 
 ```

``` c
#include <stdio.h>
int a[10] = {2, 1, 4, 5, 3, 6, 7, 8, 9, 10};

void main()
{
    int i, j, k, min, n = 10;
    for (i = 0; i <= n - 2; i++)
    {
        min = i;
        for (j = i + 1; j <= n - 1; j++)
        {
            if (a[i] > a[j])
            {
                min = j;
            }
        }
        if (min != i)
        {
            k = a[min];
            a[min] = a[i];
            a[i] = k;
        }
    }
    for (i = 0; i <= n - 1; i++)
    {
        printf("%d ", a[i]);
    }
}
```
