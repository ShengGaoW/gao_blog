<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>事件循环 | 大芒果</title>
    <meta name="generator" content="VuePress 1.7.1">
    <link rel="icon" href="https://shenggao.oss-cn-beijing.aliyuncs.com/info/head.jpg">
    <meta name="description" content="大芒的博客果">
    
    <link rel="preload" href="/assets/css/0.styles.992cb7aa.css" as="style"><link rel="preload" href="/assets/js/app.5585b3f9.js" as="script"><link rel="preload" href="/assets/js/2.b244e696.js" as="script"><link rel="preload" href="/assets/js/25.74376702.js" as="script"><link rel="prefetch" href="/assets/js/10.84ec4af0.js"><link rel="prefetch" href="/assets/js/11.b82a4cc7.js"><link rel="prefetch" href="/assets/js/12.5a82f935.js"><link rel="prefetch" href="/assets/js/13.8fb03669.js"><link rel="prefetch" href="/assets/js/14.a65a4b04.js"><link rel="prefetch" href="/assets/js/15.820a25bd.js"><link rel="prefetch" href="/assets/js/16.8f6e6bdb.js"><link rel="prefetch" href="/assets/js/17.aefa299d.js"><link rel="prefetch" href="/assets/js/18.d02b08a2.js"><link rel="prefetch" href="/assets/js/19.0f5db60b.js"><link rel="prefetch" href="/assets/js/20.01c484b7.js"><link rel="prefetch" href="/assets/js/21.23d318b7.js"><link rel="prefetch" href="/assets/js/22.8d4451d0.js"><link rel="prefetch" href="/assets/js/23.e93d754a.js"><link rel="prefetch" href="/assets/js/24.f062c1c5.js"><link rel="prefetch" href="/assets/js/26.0173a179.js"><link rel="prefetch" href="/assets/js/27.cda7894e.js"><link rel="prefetch" href="/assets/js/28.30a31dc3.js"><link rel="prefetch" href="/assets/js/29.d5de6641.js"><link rel="prefetch" href="/assets/js/3.941c99e3.js"><link rel="prefetch" href="/assets/js/30.c549cc57.js"><link rel="prefetch" href="/assets/js/31.06fe8ca4.js"><link rel="prefetch" href="/assets/js/32.e5bff65c.js"><link rel="prefetch" href="/assets/js/33.349e8ed7.js"><link rel="prefetch" href="/assets/js/34.5a8cb550.js"><link rel="prefetch" href="/assets/js/4.09fd2c39.js"><link rel="prefetch" href="/assets/js/5.fc791712.js"><link rel="prefetch" href="/assets/js/6.ffe6f60a.js"><link rel="prefetch" href="/assets/js/7.d0c6d7a4.js"><link rel="prefetch" href="/assets/js/8.fce5d855.js"><link rel="prefetch" href="/assets/js/9.8432ac8c.js">
    <link rel="stylesheet" href="/assets/css/0.styles.992cb7aa.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="https://shenggao.oss-cn-beijing.aliyuncs.com/info/head.jpg" alt="大芒果" class="logo"> <span class="site-name can-hide">大芒果</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/fronted/" class="nav-link router-link-active">
  前端
</a></div><div class="nav-item"><a href="/backend/" class="nav-link">
  后端
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">计算机</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">计算机</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/language/chinese/" class="nav-link">
  计算机组成原理
</a></li><li class="dropdown-item"><!----> <a href="/language/japanese/" class="nav-link">
  操作系统
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/fronted/" class="nav-link router-link-active">
  前端
</a></div><div class="nav-item"><a href="/backend/" class="nav-link">
  后端
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">计算机</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">计算机</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/language/chinese/" class="nav-link">
  计算机组成原理
</a></li><li class="dropdown-item"><!----> <a href="/language/japanese/" class="nav-link">
  操作系统
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>javascript</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fronted/js/函数式编程.html" class="sidebar-link">函数式编程</a></li><li><a href="/fronted/js/如何发布npm包.html" class="sidebar-link">如何发布一个 npm 包</a></li><li><a href="/fronted/js/数组去重.html" class="sidebar-link">数组去重</a></li><li><a href="/fronted/js/bind、call和apply实现.html" class="sidebar-link">bind、call和apply自定义实现</a></li><li><a href="/fronted/js/拖拽实现.html" class="sidebar-link">js原生实现拖拽</a></li><li><a href="/fronted/js/数据类型检测.html" class="sidebar-link">JS 数据类型检测</a></li><li><a href="/fronted/js/ajax、fetch和jsonp.html" class="sidebar-link">客户端请求</a></li><li><a href="/fronted/js/正则表达式.html" class="sidebar-link">正则表达式</a></li><li><a href="/fronted/js/h5新增事件.html" class="sidebar-link">HTML5事件</a></li><li><a href="/fronted/js/react框架key的作用.html" class="sidebar-link">深入理解 key（react）</a></li><li><a href="/fronted/js/reactHook问题总结.html" class="sidebar-link">reactHook 理解与应用</a></li><li><a href="/fronted/js/ts学习.html" class="sidebar-link">ts 学习笔记</a></li><li><a href="/fronted/js/事件循环.html" class="active sidebar-link">事件循环</a></li><li><a href="/fronted/js/pwa.html" class="sidebar-link">前端本地缓存之PWA篇</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>css</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>webpack</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>react-native</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="事件循环"><a href="#事件循环" class="header-anchor">#</a> 事件循环</h1> <p><strong>引言</strong></p> <p>javascript 是一门单线程的语言，在同一个时间只能做完成一件任务，如果有多个任务，就必须排队，前面一个任务完成，再去执行后面的任务。作为浏览器端的脚本语言，javascript 的主要功能是用来和用户交互以及操作 dom。假设 javascript 不是单线程语言，在一个线程里我们给某个 dom 节点增加内容的时候，另一个线程同时正在删除这个 dom 节点的内容，则会造成混乱。</p> <p>由于 js 单线程的设计，假设 js 程序的执行都是同步。如果执行一些耗时较长的程序，例如 ajax 请求，在请求开始至请求响应的这段时间内，当前的工作线程一直是空闲状态， ajax 请求后面的 js 代码只能等待请求结束后执行，因此会导致 js 阻塞的问题。</p> <p>javascript 单线程指的是浏览器中负责解释和执行 javascript 代码的只有一个线程，即为 js 引擎线程，但是浏览器的渲染进程是提供多个线程的，如下：</p> <ol><li>js 引擎线程</li> <li>事件触发线程</li> <li>定时器触发线程</li> <li>异步 http 请求线程</li> <li>GUI 渲染线程</li></ol> <h2 id="一、异步-同步"><a href="#一、异步-同步" class="header-anchor">#</a> 一、异步 &amp; 同步</h2> <p>为解决上述类似上述 js 阻塞的问题，js 引入了同步和异步的概念。</p> <h3 id="_1、什么是同步"><a href="#_1、什么是同步" class="header-anchor">#</a> 1、什么是同步？</h3> <p>“同步”就是后一个任务等待前一个任务结束后再去执行。</p> <h3 id="_2、什么是异步"><a href="#_2、什么是异步" class="header-anchor">#</a> 2、什么是异步？</h3> <p>“异步”与同步不同，每一个异步任务都有一个或多个回调函数。webapi 会在其相应的时机里将回调函数添加进入消息队列中，不直接执行，然后再去执行后面的任务。直至当前同步任务执行完毕后，再把消息队列中的消息添加进入执行栈进行执行。</p> <p>异步任务在浏览器中一般是以下：</p> <ol><li>网络请求</li> <li>计时器</li> <li>DOM 监听事件</li> <li>...</li></ol> <h2 id="二、什么是执行栈-stack-、堆-heap-、事件队列-task-queue"><a href="#二、什么是执行栈-stack-、堆-heap-、事件队列-task-queue" class="header-anchor">#</a> 二、什么是执行栈(stack)、堆(heap)、事件队列(task queue)？</h2> <p><img src="https://shenggao.oss-cn-beijing.aliyuncs.com/blog/2020/10/data" alt=""></p> <h3 id="_1、执行栈"><a href="#_1、执行栈" class="header-anchor">#</a> 1、执行栈</h3> <blockquote><p>“栈”是一种数据结构，是一种线性表。特点为 LIFO，即先进后出 （last in, first out）。</p></blockquote> <p>利用数组的 push 和 shift 可以实现压栈和出栈的操作。</p> <p><img src="https://shenggao.oss-cn-beijing.aliyuncs.com/blog/2020/09/stack.png" alt="stack"></p> <p>在代码运行的过程中，函数的调用会形成一个由若干帧组成的栈。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> a <span class="token operator">+</span> b <span class="token operator">+</span> <span class="token number">11</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">foo</span><span class="token punctuation">(</span>x <span class="token operator">*</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>上面代码最终会在控制台打印 42,下面梳理一下它的执行顺序。</p> <ol><li>console.log 函数作为第一帧压入栈中。</li> <li>调用 bar，第二帧被压入栈中。帧中包含着 bar 的变量对象。</li> <li>bar 调用 foo，foo 做一位第三帧被压入栈中，帧中包含着 foo 的变量对象。</li> <li>foo 执行完毕然后返回。被弹出栈。</li> <li>bar 执行完毕然后返回，被弹出栈。</li> <li>log 函数接收到 bar 的返回值。执行完毕后，出栈。此时栈已空。</li></ol> <p><img src="https://shenggao.oss-cn-beijing.aliyuncs.com/blog/2020/09/stackcall.png" alt=""></p> <h3 id="_2、堆"><a href="#_2、堆" class="header-anchor">#</a> 2、堆</h3> <blockquote><p>对象被分配在堆中，堆是一个用来表示一大块（通常是非结构化的）内存区域的计算机术语。</p></blockquote> <h4 id="堆和栈的区别"><a href="#堆和栈的区别" class="header-anchor">#</a> 堆和栈的区别</h4> <p>首先，stack 是有结构的，每个区块按照一定次序存放，可以明确知道每个区块的大小；heap 是没有结构的，数据可以任意存放。因此，
stack 的寻址速度要快于 heap。</p> <p>其次，每个线程分配一个 stack，每个进程分配一个 heap，也就是说，stack 是线程独占的，heap 是线程共用的。</p> <p>此外，stack 创建的时候，大小是确定的，数据从超过这个大小，就发生 stack overflow 错误，而 heap 的大小是不确定的，
需要的话可以不断增加。</p> <div class="language-java extra-class"><pre class="language-java"><code>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token class-name">Method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> y<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>

    class1 cls1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">class1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>上面代码这三个变量和一个对象实例在内存中的存放方式如下。</p> <p><img src="https://shenggao.oss-cn-beijing.aliyuncs.com/blog/2020/09/stackCall.jpg" alt=""></p> <p>从上图可以看到，i、y 和 cls1 都存放在 stack，因为它们占用内存空间都是确定的，而且本身也属于局部变量。但是，cls1 指向的对象实例存放在 heap，因为它的大小不确定。作为一条规则可以记住，所有的对象都存放在 heap。</p> <p>接下来的问题是，当 Method1 方法运行结束，会发生什么事？</p> <p>回答是整个 stack 被清空，i、y 和 cls1 这三个变量消失，因为它们是局部变量，区块一旦运行结束，就没必要再存在了。而 heap 之中的那个对象实例继续存在，直到系统的垃圾清理机制（garbage collector）将这块内存回收。因此，一般来说，内存泄漏都发生在 heap，即某些内存空间不再被使用了，却因为种种原因，没有被系统回收。</p> <h3 id="_3、事件队列和事件循环"><a href="#_3、事件队列和事件循环" class="header-anchor">#</a> 3、事件队列和事件循环</h3> <blockquote><p>队列是一种数据结构，也是一种特殊的线性表。特点为 FIFO，即先进先出（first in, first out）</p></blockquote> <p>利用数组的 push 和 pop 可实现入队和出队的操作。</p> <p><img src="https://shenggao.oss-cn-beijing.aliyuncs.com/blog/2020/09/queue.png" alt=""></p> <p>事件循环和事件队列的维护是由事件触发线程控制的。</p> <p>事件触发线程线程同样是由浏览器渲染引擎提供的，它会维护一个事件队列。</p> <p>js 引擎遇到上文所列的异步任务后，会交个相应的线程去维护异步任务，等待某个时机，然后由事件触发线程将异步任务对应的回调函数加入到事件队列中，事件队列中的函数等待被执行。</p> <p>js 引擎在执行过程中，遇到同步任务，会将任务直接压入执行栈中执行，当执行栈为空（即 js 引擎线程空闲），<strong>事件触发线程</strong>会从事件队列中取出一个任务（即异步任务的回调函数）放入执行在栈中执行。</p> <p>执行完了之后，执行栈再次为空，事件触发线程会重复上一步的操作，再从事件队列中取出一个消息，这种机制就被称为<strong>事件循环</strong>（Event Loop）机制。</p> <p>为了更好地理解 Event Loop，请看下图（转引自 Philip Roberts 的演讲《Help, I'm stuck in an event-loop》）。</p> <p><img src="https://shenggao.oss-cn-beijing.aliyuncs.com/blog/2020/10/eventloop.png" alt=""></p> <p>例子代码：</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;script start&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;timer 1 over&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;timer 2 over&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;script end&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// script start</span>
<span class="token comment">// script end</span>
<span class="token comment">// timer 2 over</span>
<span class="token comment">// timer 1 over</span>
</code></pre></div><p>模拟 js 引擎对其执行过程：</p> <p><strong>第一轮事件循环：</strong></p> <ol><li>console.log 为同步任务，入栈，打印“script start”。出栈。</li> <li>setTimeout 为异步任务，入栈，交给定时器触发线程处理（在 1 秒后加入将回调加入事件队列）。出栈。</li> <li>setTimeout 为异步任务，入栈，交给定时器触发线程处理（在 4ms 之内将回调加入事件队列）。出栈。</li> <li>console.log 为同步任务，入栈，打印&quot;script end&quot;。出栈。</li></ol> <p>此时，执行栈为空，js 引擎线程空闲。便从事件队列中读取任务，此时队列如下：</p> <p><img src="https://shenggao.oss-cn-beijing.aliyuncs.com/blog/2020/10/%E6%89%A7%E8%A1%8C%E9%98%9F%E5%88%97.png" alt=""></p> <p><strong>第二轮事件循环</strong></p> <ol start="5"><li>js 引擎线程从事件对列中读取 cb2 加入执行栈并执行，打印”time 2 over“。出栈。</li></ol> <p><strong>第三轮事件循环</strong></p> <ol start="6"><li>js 引擎从事件队列中读取 cb1 加入执行栈中并执行，打印”time 1 over“ 。出栈。</li></ol> <p>注意点：</p> <p>上面，timer 2 的延时为 0ms，HTML5 标准规定 setTimeout 第二个参数不得小于 4（不同浏览器最小值会不一样），不足会自动增加，所以 &quot;timer 2 over&quot; 还是会在 &quot;script end&quot; 之后。</p> <p>就算延时为 0ms,只是 time 2 的回调函数会立即加入事件队列而已，回调的执行还是得等到执行栈为空时执行。</p> <h2 id="四、宏任务-微任务"><a href="#四、宏任务-微任务" class="header-anchor">#</a> 四、宏任务 &amp; 微任务</h2> <p>在 ES6 新增 Promise 处理异步后，js 执行引擎的处理过程又发生了新的变化。</p> <p>看代码：</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;script start&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;timer over&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;promise1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;promise2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;script end&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// script start</span>
<span class="token comment">// script end</span>
<span class="token comment">// promise1</span>
<span class="token comment">// promise2</span>
<span class="token comment">// timer over</span>
</code></pre></div><p>这里又新增了两个新的概念，<strong>macrotask</strong> （宏任务）和 <strong>microtask</strong>（微任务）。</p> <p>所有的任务都划分到宏任务和微任务下：</p> <ul><li><strong>macrotask</strong>: script 主代码块、setTimeout、setInterval、requestAnimationFrame、node 中的 setimmediate 等。</li> <li><strong>microtask</strong>: Promise.then catch finally、MutationObserver、node 中的 process.nextTick 等。</li></ul> <p>js 引擎首先执行主代码块。</p> <p>执行栈每次执行的代码就是一个宏任务，包括任务队列（宏任务队列）中的。执行栈中的任务执行完毕后，js 引擎会从宏任务队列中去添加任务到执行栈中，即同样是事件循环的机制。</p> <p>当在执行宏任务遇到微任务 Promise.then 时，会创建一个微任务，并加入到微任务队列中的队尾。</p> <p>微任务是在宏任务执行的时候创建的，而在下一个宏任务执行之前，浏览器会对页面重新渲染（task &gt;&gt; render &gt;&gt; task（任务队列中读取））。<strong>同时，在上一个宏任务执行完成后，页面渲染之前，会执行当前微任务队列中的所有微任务。</strong></p> <p><img src="https://shenggao.oss-cn-beijing.aliyuncs.com/blog/2020/10/task.png" alt=""></p> <p>所以上述代码的执行过程就可以解释了。</p> <p>js 引擎执行 promise.then 时，promise1、promise2 被认为是两个微任务按照代码的先后顺序被加入到微任务队列中，script end 执行后，栈空。</p> <p>此时当前宏任务（script 主代码块）执行完毕，并不从当前宏任务队列中读取任务。而是立马清空当前宏任务所产生的微任务队列。将两个微任务依次放入执行栈中执行。执行完毕，打印 promise1、promise2。栈空。<strong>此时，第一轮事件循环结束。</strong></p> <p>紧接着，再去读取宏任务队列中的任务，time over 被打印。栈空。</p> <p>因此，宏任务和微任务的执行机制如下：</p> <ol><li>执行一个宏任务（栈中没有就从宏任务队列中获取）</li> <li>执行过程中遇到微任务，就将它添加到微任务的任务队列中</li> <li>宏任务执行完毕，立即执行当前微任务队列中的所有微任务（依次执行）</li> <li>当前所有微任务执行完毕后，开始检查渲染，GUI 线程接管渲染</li> <li>渲染完毕后，JS 引擎继续开始下一个宏任务，从宏任务队列中获取</li></ol> <h3 id="async-await"><a href="#async-await" class="header-anchor">#</a> async &amp; await</h3> <p>因为,async 和 await 本质上还是基于 Promise 的封装，而 Promise 是属于微任务的一种。所以使用 await 关键字与 Promise.then 效果类似：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">_</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">await</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 1</span>
<span class="token comment">// 2</span>
<span class="token comment">// 3</span>
<span class="token comment">// 4</span>
</code></pre></div><p>async 函数在 await 之前的代码都是同步执行的，<strong>可以理解为 await 之前的代码都属于 new Promise 时传入的代码，await 之后的所有代码都是 Promise.then 中的回调，即在微任务队列中。</strong></p> <h2 id="五、总结"><a href="#五、总结" class="header-anchor">#</a> 五、总结</h2> <ol><li>js 单线程实际上时解释执行 js 代码的只有一个线程，但是浏览器的渲染是多线程的。</li> <li>异步和同步的概念与区别，异步任务有哪些。</li> <li>栈、堆、队列的特点和使用场景。</li> <li>事件队列以及事件循环机制。</li> <li>es6 下，宏任务与微任务的执行过程。</li></ol> <hr> <p>参考：</p> <ul><li><a href="https://juejin.im/post/6844903711106400264#refetch" target="_blank" rel="noopener noreferrer">JavaScript 异步与事件循环<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop" target="_blank" rel="noopener noreferrer">并发模型与事件循环<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://juejin.im/post/6844903657264136200" target="_blank" rel="noopener noreferrer">微任务、宏任务与 Event-Loop<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener noreferrer">JavaScript 运行机制详解：再谈 Event Loop<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://juejin.im/post/6844903577052250119" target="_blank" rel="noopener noreferrer">JS 事件循环<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.cnblogs.com/dong-xu/p/7000139.html" target="_blank" rel="noopener noreferrer">[译] 深入理解 JavaScript 事件循环（二）— task and microtask
<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://vimeo.com/96425312" target="_blank" rel="noopener noreferrer">Help, I'm stuck in an event-loop<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/fronted/js/ts学习.html" class="prev">
        ts 学习笔记
      </a></span> <span class="next"><a href="/fronted/js/pwa.html">
        前端本地缓存之PWA篇
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.5585b3f9.js" defer></script><script src="/assets/js/2.b244e696.js" defer></script><script src="/assets/js/25.74376702.js" defer></script>
  </body>
</html>
